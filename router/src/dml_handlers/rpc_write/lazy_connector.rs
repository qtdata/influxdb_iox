//! A lazy connector for Tonic gRPC [`Channel`] instances.

use std::{
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc,
    },
    time::Duration,
};

use async_trait::async_trait;
use generated_types::influxdata::iox::ingester::v1::{
    write_service_client::WriteServiceClient, WriteRequest,
};
use observability_deps::tracing::*;
use parking_lot::Mutex;
use tokio::task::JoinHandle;
use tonic::{
    metadata::AsciiMetadataValue,
    transport::{Channel, Endpoint},
    Code,
};

use super::{client::WriteClient, RpcWriteError};

const RETRY_INTERVAL: Duration = Duration::from_secs(1);
const CONNECT_TIMEOUT: Duration = Duration::from_secs(1);

/// How many consecutive errors must be observed before opening a new connection
/// (at most once per [`RETRY_INTERVAL]).
const RECONNECT_ERROR_COUNT: usize = 10;

/// Lazy [`Channel`] connector.
///
/// Connections are attempted in a background thread every [`RETRY_INTERVAL`].
/// once a connection has been established, the [`Channel`] internally handles
/// reconnections as needed.
///
/// Returns [`RpcWriteError::UpstreamNotConnected`] when no connection is
/// available.
#[derive(Debug)]
pub struct LazyConnector {
    addr: Endpoint,
    connection: Arc<Mutex<Option<Channel>>>,

    /// The number of request errors observed without a single success.
    consecutive_errors: Arc<AtomicUsize>,
    /// A task that periodically opens a new connection to `addr` when
    /// `consecutive_errors` is more than [`RECONNECT_ERROR_COUNT`].
    connection_task: JoinHandle<()>,
}

impl LazyConnector {
    /// Lazily connect to `addr`.
    pub fn new(addr: Endpoint, request_timeout: Duration) -> Self {
        let addr = addr
            .connect_timeout(CONNECT_TIMEOUT)
            .timeout(request_timeout);
        let connection = Default::default();

        // Drive first connection by setting it above the connection limit.
        let consecutive_errors = Arc::new(AtomicUsize::new(RECONNECT_ERROR_COUNT + 1));
        Self {
            addr: addr.clone(),
            connection: Arc::clone(&connection),
            connection_task: tokio::spawn(try_connect(
                addr,
                connection,
                Arc::clone(&consecutive_errors),
            )),
            consecutive_errors,
        }
    }

    /// Returns `true` if a connection was established at some point in the
    /// past.
    ///
    /// If true, the connection may be active and healthy, or currently
    /// unusable.
    pub fn did_connect(&self) -> bool {
        self.connection.lock().is_some()
    }
}

#[async_trait]
impl WriteClient for LazyConnector {
    async fn write(&self, op: WriteRequest) -> Result<(), RpcWriteError> {
        let conn = self.connection.lock().clone();
        let conn =
            conn.ok_or_else(|| RpcWriteError::UpstreamNotConnected(self.addr.uri().to_string()))?;

        match WriteServiceClient::new(conn).write(op).await {
            Err(e) if is_envoy_unavailable_error(&e) => {
                warn!(error=%e, "detected envoy proxy upstream network error translation, reconnecting");
                self.consecutive_errors
                    .store(RECONNECT_ERROR_COUNT + 1, Ordering::Relaxed);
                return Err(e);
            }
            Err(e) => {
                self.consecutive_errors.fetch_add(1, Ordering::Relaxed);
                return Err(e);
            }
            Ok(_) => {
                self.consecutive_errors.store(0, Ordering::Relaxed);
                Ok(())
            }
        }
    }
}

/// Returns `true` if `e` is a gRPC error with the status [`Code::Unavailable`],
/// and a metadata entry indicating the response was generated by an envoy proxy
/// instance.
///
/// This is needed because the envoy proxy effectively converts network errors
/// (dial & I/O errors) into application-level (gRPC) errors, much like a pure
/// HTTP proxy would. Unfortunately this is a breaking change in behaviour for
/// networking code like [`tonic`]'s transport implementation, which can no
/// longer easily differentiate network errors from actual application errors.
fn is_envoy_unavailable_error(e: &RpcWriteError) -> bool {
    match e {
        RpcWriteError::Upstream(e) if e.code() == Code::Unavailable => e
            .metadata()
            .get("server")
            .map(|v| v == AsciiMetadataValue::from_static("envoy"))
            .unwrap_or(false),
        RpcWriteError::Upstream(_)
        | RpcWriteError::Timeout(_)
        | RpcWriteError::NoUpstreams
        | RpcWriteError::UpstreamNotConnected(_)
        | RpcWriteError::DeletesUnsupported => false,
    }
}

impl Drop for LazyConnector {
    fn drop(&mut self) {
        self.connection_task.abort();
    }
}

async fn try_connect(
    addr: Endpoint,
    connection: Arc<Mutex<Option<Channel>>>,
    consecutive_errors: Arc<AtomicUsize>,
) {
    loop {
        if consecutive_errors.load(Ordering::Relaxed) > RECONNECT_ERROR_COUNT {
            match addr.connect().await {
                Ok(v) => {
                    info!(endpoint = %addr.uri(), "connected to upstream ingester");
                    *connection.lock() = Some(v);
                    consecutive_errors.store(0, Ordering::Relaxed);
                }
                Err(e) => warn!(
                    endpoint = %addr.uri(),
                    error=%e,
                    "failed to connect to upstream ingester"
                ),
            }
        }
        tokio::time::sleep(RETRY_INTERVAL).await;
    }
}
